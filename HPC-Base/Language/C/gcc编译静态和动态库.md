# gcc编译

[链接](https://blog.csdn.net/qq_46017342/article/details/129110423)

## GCC编译理论

首先需要知道GCC编译命令与过程, GCC编译可以分为四个步骤：一般常用的只有-C汇编和无参数链接

GCC编译常见参数：
```
-I 指定头文件所在目录位置,注意-I和目录之间没有空格
-c 只做预处理，编译，汇编。得到二进制文件
-g 编译时添加调试文件，用于gdb调试
-Wall 显示所有警告信息
-D 向程序中“动态”注册宏定义
-l 指定动态库库名
-L 指定动态库路径
```

当头文件和源码不在一个目录下时，需要指定头文件

gcc -I ./hellodir hello.c -o hello

其中-I参数指定头文件所在位置，位置可以在编译文件前，也可以在后面

## 动态库与静态库
### 理论对比

静态库是在可执行程序运行前就已经加入到执行码中，成为执行程序的一部分；
共享库，是在执行程序启动时加载到执行程序中，可以被多个执行程序共享使用。
建议库开发人员创建共享库，比较明显的优势在于库是独立的，便于维护和更新；而静态库的更新比较麻烦，一般不做推荐。然而，它们又各有优点，静态库在文件中静态展开，所以有多少文件就展开多少次，非常吃内存，100M展开100次，就是1G，但是这样的好处就是静态加载的速度快
使用动态库会将动态库加载到内存，10个文件也只需要加载一次，然后这些文件用到库的时候临时去加载，速度慢一些，但是很省内存
动态库和静态库各有优劣，根据实际情况合理选用即可

### 静态库使用

静态库名字以lib开头，以.a结尾

例如：libmylib.a

静态库生成指令:  ar rcs libmylib.a file1.o

步骤一：
写好源代码

步骤二：
编译源代码生成.o文件

步骤三：
制作静态库
ar rcs libname.a file1.o file2.o …

静态库的使用： gcc test.c lib库名.a -o a.out

## 动态库的使用
### 动态库理论知识

写在源代码里的函数，相对main函数偏移是一定的，链接时，回填main函数地址之后，其他源代码里的函数也就得到了地址。
动态库里的函数会用一个@plt（详细的再操作系统中动态重定位中有学习，大致就是用一个寄存器记录位置，用相对位置的改变记录其他函数）来标识，当动态库加载到内存时，再用加载进去的地址将@plt替换掉。

### 制作动态库的步骤

1.生成位置无关的.o文件

gcc -c add.c -o add.o -fPIC

使用这个参数过后，生成的函数就和位置无关，挂上@plt标识，等待动态绑定

2. 使用 gcc -shared制作动态库

gcc -shared -o lib库名.so add.o sub.o div.o

3. 编译可执行程序时指定所使用的动态库:

-l:指定库名 -L:指定库路径

gcc test.c -o a.out -l mymath -L ./lib

4. 设置环境变量

export LD_LIBRARY_PATH=动态库路径

5. 运行可执行程序   
./a.out

过程演示：

步骤一：生成位置无关的.o文件
```
gcc -c add.c -o add.o -fPIC
gcc -c sub.c -o sub.o -fPIC
```
步骤二：制作动态库 

gcc -shared -o lib库名.so add.o sub.o div.o

步骤三：编译程序

将动态库放在lib目录下，将头文件放在inc目录下

文件分布如下：动态库在lib目录下，头文件在inc目录下

指定动态库路径并使其生效，然后再执行文件

通过环境变量指定动态库所在位置：export LD_LIBRARY_PATH=动态库路径





